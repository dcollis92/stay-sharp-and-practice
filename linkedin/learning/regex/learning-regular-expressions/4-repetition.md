# Learning Regular Expressions

## __Ch4. Repetition__

----

## 4.1 Repetition Metacharacters

Transcript:
In this chapter we will learn to use repetition in our regular expressions to help us to write more complex patterns. There are three repetition metacharacters we need to learn; the asterisk, the plus sign and the question mark. All three of them are going to go after something else in a regular expression and that something else is going to be repeated a certain number of times based on which one of these metacharacters we use. If we use the asterisk then the preceding item will be repeated either zero times or more. So it may not exist at all, it's completely optional. Or, it may be there one time, two times, three times, an indeterminate number of times. If we use the plus sign then that preceding item must exist at least once but it could be repeated as many times as necessary. And then the third one, the question mark, says the preceding item would exist either zero or one time. You can also think of it as being optional. It may be there, or it may not be there, but it can't be repeated any more than one time. The most common of these by far is the plus sign and it's frequently paired with the wild card metacharacter. A period and a plus sign matches any string of characters except on line return. That's a great way to just say there's something here, some characters, and I don't really care what they are. For example, if we had Good and then a space and then a wild card followed by the plus repetition metacharacter and then a literal period after it, it would match "Good morning", "Good day", "Good evening" and "Good night". We're essentially just having a place holder there saying there's a wild card for some amount of characters that must start with the word good and a space and end with a period. You can also pair it with a shorthand metacharacter so we we have backslash D and a plus who would match any number of digits. Or, you can use it with a character set. Here I have a character set A to Z with the plus sign after it, before it is the shorthand for a space, afterwards it ends in "ed" and another space. So, that's going to match lowercase words that end in "ed". Doesn't matter what characters are there before, doesn't matter how long the word is, they just have to have a space before it and a space after it and an "ed" at the end of the word. Let's look at some of the differences between the different repetition metacharacters. If we have apples with an asterisk it would match apple, apples and apples with a whole bunch of s's. If we had apples with a plus sign it would match apples and apples with all the s's but not the singular word apple. The S is required in this case whereas with the asterisk it was optional. And then there's that question mark which just makes the S optional. So it'd match apple and apples but not any number of s's beyond that, there can only be one S. Sometimes choosing between the asterisk and the plus sign is just a matter of style. For example, you could have four backslash d's for any digit with an asterisk at the end and it would match numbers with three digits or more. If you did the same thing using three d's and a plus sign it would match digits with three digits or more also. That's because in the first example that fourth D is optional. Personally I find the second one to be a little clearer about what our intentions are. Another handy use of the question mark is when you have words that might be spelled different ways. If you wanted to search a document for the word color spelled C-O-L-O-R and also spelled C-O-L-O-U-R then you could just put a question mark after that letter. That letter may or may not be present when we're searching for it. Let's try some examples. So let's start with that apples example. For our text let's just write apple, apples, and apples with a whole bunch of s's. Let's come up here in our regular expression, using the global flag it's going to be A-P-P-L and you see it matches apple, and all of those words. Let's go ahead and put a space after it too just so that we know that there's a space that ends the word. So you can see now it only matches the first one, right? No longer matches this one because we don't have the S there. So, let's add the S. Now it matches the second one but not the first one any more. If we put a question mark after it, now the S is optional. It matches apple and apples but doesn't allow us to repeat it more times. If we put the asterisk after it, now it matches the first two. It's not matching the last one because I don't have a space here, let's just add a space and you'll see now it matches that one as well. So apple space, apples space and applesssss space. All of those work. Now let's just change to the plus sign and now you'll see that it works for apples and apples with all the s's but it doesn't work for apple by itself. Play around with that til you get a feel for each one of those. Now if we had numbers like 90210 and of course up here we could change these to be just a digit repeated. I'll take away the space and now you can see that it matches any number of digits and if I just keep typing digits, let's type 34567 it still just keeps going, it's indeterminate in its length. Now of course we could do this another way, instead of repeating it we could just say backslash D, backslash D, backslash D, backslash D, but this saves us from having to do that. We don't have to type them all out, we can just use that repetition operator instead. Let's try our example with "Good morning". Let's do a new line, "Good day", "Good Evening" and "Good night". And you have to make sure you have a line return after each one of those. Now let's just try doing the dot, the wild card and then the plus. So, remember that matches anything but a new line. Now let's take away the global flag just so we can see what's going on here. It's only matching this amount of text. So anything but a new line gets matched. It essentially grabs the entire line for us. Let's turn back on global again so it matches all of them, so we're getting four matches. Now let's just try making this a little more specific. Let's say we're looking for something that starts with the word good, has a space and then at the end, ends with a literal period. So now you can see it's matching each one of these; morning, day, evening, night. Doesn't matter what the characters are, doesn't matter how long it is, it's going to make a match. So, these repetition operators are useful because it keeps us from repeating ourselves. We don't have to just type dot, dot, dot three times we can just use the plus sign instead. But also notice when I do dot, dot, dot I've now made it a fixed length that's only three characters. If I wanted to match night I have to add two more characters. So it also allows us to have matches of indeterminate repetition. So it can match one time, two times, three times, four times, five times, it really doesn't matter. It makes the repetition metacharacters a very useful tool for writing regular expressions.

----

### __----- BULLET POINT NOTES -----__

| Metacharacter    | Meaning                            |
| :--------------- |:---------------------------------- |
| `*`              | Preceding item, zero or more times |
| `+`              | Preceding item, one or more times  |
| `?`              | Preceding item, zero or one time   |

### Repetition Metacharacters
  - `/.+/` matches any string of characters except a line return
  - `/Good .+\./` matches "Good morning.", "Good day.", "Good evening.", and "Good night."
  - `/\d+/` matches "90210"
  - `/\s[a-z]+ed\s/` matches lowercase words ending in "ed"
  - `/apples*/` matches "apple", "apples", and "applesssss"
  - `/apple+/` matches "apples" and "applesssss", but not "apple"
  - `/apple?/` matches "apple" and "apples", but not "applessssss"
  - `/\d\d\d\d*/` matches numbers with three digits or more
  - `/\d\d\d\d+/` matches numbers with three digits or more
  - `/colou?r/` matches "color" and "colour"

### regexr example:
  - text: Good morning.
          Good day.
          Good evening.
          Good night. 
    - regex:` /Good .+\./g` (4 matches, all)

