# Learning Regular Expressions

## __Ch4. Repetition__

----

## 4.1 Repetition Metacharacters

Transcript:
In this chapter we will learn to use repetition in our regular expressions to help us to write more complex patterns. There are three repetition metacharacters we need to learn; the asterisk, the plus sign and the question mark. All three of them are going to go after something else in a regular expression and that something else is going to be repeated a certain number of times based on which one of these metacharacters we use. If we use the asterisk then the preceding item will be repeated either zero times or more. So it may not exist at all, it's completely optional. Or, it may be there one time, two times, three times, an indeterminate number of times. If we use the plus sign then that preceding item must exist at least once but it could be repeated as many times as necessary. And then the third one, the question mark, says the preceding item would exist either zero or one time. You can also think of it as being optional. It may be there, or it may not be there, but it can't be repeated any more than one time. The most common of these by far is the plus sign and it's frequently paired with the wild card metacharacter. A period and a plus sign matches any string of characters except on line return. That's a great way to just say there's something here, some characters, and I don't really care what they are. For example, if we had Good and then a space and then a wild card followed by the plus repetition metacharacter and then a literal period after it, it would match "Good morning", "Good day", "Good evening" and "Good night". We're essentially just having a place holder there saying there's a wild card for some amount of characters that must start with the word good and a space and end with a period. You can also pair it with a shorthand metacharacter so we we have backslash D and a plus who would match any number of digits. Or, you can use it with a character set. Here I have a character set A to Z with the plus sign after it, before it is the shorthand for a space, afterwards it ends in "ed" and another space. So, that's going to match lowercase words that end in "ed". Doesn't matter what characters are there before, doesn't matter how long the word is, they just have to have a space before it and a space after it and an "ed" at the end of the word. Let's look at some of the differences between the different repetition metacharacters. If we have apples with an asterisk it would match apple, apples and apples with a whole bunch of s's. If we had apples with a plus sign it would match apples and apples with all the s's but not the singular word apple. The S is required in this case whereas with the asterisk it was optional. And then there's that question mark which just makes the S optional. So it'd match apple and apples but not any number of s's beyond that, there can only be one S. Sometimes choosing between the asterisk and the plus sign is just a matter of style. For example, you could have four backslash d's for any digit with an asterisk at the end and it would match numbers with three digits or more. If you did the same thing using three d's and a plus sign it would match digits with three digits or more also. That's because in the first example that fourth D is optional. Personally I find the second one to be a little clearer about what our intentions are. Another handy use of the question mark is when you have words that might be spelled different ways. If you wanted to search a document for the word color spelled C-O-L-O-R and also spelled C-O-L-O-U-R then you could just put a question mark after that letter. That letter may or may not be present when we're searching for it. Let's try some examples. So let's start with that apples example. For our text let's just write apple, apples, and apples with a whole bunch of s's. Let's come up here in our regular expression, using the global flag it's going to be A-P-P-L and you see it matches apple, and all of those words. Let's go ahead and put a space after it too just so that we know that there's a space that ends the word. So you can see now it only matches the first one, right? No longer matches this one because we don't have the S there. So, let's add the S. Now it matches the second one but not the first one any more. If we put a question mark after it, now the S is optional. It matches apple and apples but doesn't allow us to repeat it more times. If we put the asterisk after it, now it matches the first two. It's not matching the last one because I don't have a space here, let's just add a space and you'll see now it matches that one as well. So apple space, apples space and applesssss space. All of those work. Now let's just change to the plus sign and now you'll see that it works for apples and apples with all the s's but it doesn't work for apple by itself. Play around with that til you get a feel for each one of those. Now if we had numbers like 90210 and of course up here we could change these to be just a digit repeated. I'll take away the space and now you can see that it matches any number of digits and if I just keep typing digits, let's type 34567 it still just keeps going, it's indeterminate in its length. Now of course we could do this another way, instead of repeating it we could just say backslash D, backslash D, backslash D, backslash D, but this saves us from having to do that. We don't have to type them all out, we can just use that repetition operator instead. Let's try our example with "Good morning". Let's do a new line, "Good day", "Good Evening" and "Good night". And you have to make sure you have a line return after each one of those. Now let's just try doing the dot, the wild card and then the plus. So, remember that matches anything but a new line. Now let's take away the global flag just so we can see what's going on here. It's only matching this amount of text. So anything but a new line gets matched. It essentially grabs the entire line for us. Let's turn back on global again so it matches all of them, so we're getting four matches. Now let's just try making this a little more specific. Let's say we're looking for something that starts with the word good, has a space and then at the end, ends with a literal period. So now you can see it's matching each one of these; morning, day, evening, night. Doesn't matter what the characters are, doesn't matter how long it is, it's going to make a match. So, these repetition operators are useful because it keeps us from repeating ourselves. We don't have to just type dot, dot, dot three times we can just use the plus sign instead. But also notice when I do dot, dot, dot I've now made it a fixed length that's only three characters. If I wanted to match night I have to add two more characters. So it also allows us to have matches of indeterminate repetition. So it can match one time, two times, three times, four times, five times, it really doesn't matter. It makes the repetition metacharacters a very useful tool for writing regular expressions.

----

### __----- BULLET POINT NOTES -----__

| Metacharacter    | Meaning                            |
| :--------------- |:---------------------------------- |
| `*`              | Preceding item, zero or more times |
| `+`              | Preceding item, one or more times  |
| `?`              | Preceding item, zero or one time   |

### Repetition Metacharacters
  - `/.+/` matches any string of characters except a line return
  - `/Good .+\./` matches "Good morning.", "Good day.", "Good evening.", and "Good night."
  - `/\d+/` matches "90210"
  - `/\s[a-z]+ed\s/` matches lowercase words ending in "ed"
  - `/apples*/` matches "apple", "apples", and "applesssss"
  - `/apple+/` matches "apples" and "applesssss", but not "apple"
  - `/apple?/` matches "apple" and "apples", but not "applessssss"
  - `/\d\d\d\d*/` matches numbers with three digits or more
  - `/\d\d\d\d+/` matches numbers with three digits or more
  - `/colou?r/` matches "color" and "colour"

### regexr example:
  - text: Good morning.
          Good day.
          Good evening.
          Good night. 
    - regex:` /Good .+\./g` (4 matches, all)

----

## 4.2 Qualified Repetition

Transcript:
Now that we've learned about repetition metacharacters, we should also talk about quantified repetition. The previous metacharacters can be repeated either zero times, one time, or an infinite number of times. But what if we want something that's more specific? Something that's a specific quantity. Let's say we want to repeat something exactly four times. Or we want to repeat it four, five, or six times, but not anything else. That's where quantified repetition comes in. We have the ability to specify the number of times something is repeated and we do that by using curly braces with some values inside. That indicates quantified repetition. So the previous item will be repeated a certain number of times. The values that we put in between those curly braces would represent the minimum time it can be repeated and the maximum time. You would do it with a minimum, comma, and the maximum. Min and max are always going to be positive numbers. The minimum must always be included, we have to know at least the minimum number of times to expect it, but it can be zero. The maximum value is optional. There's actually three different syntaxes that we can use with this. The first is that inside those curly braces we can provide both the minimum and the maximum with a comma in between. In the first example, the regular expression would match numbers with four to eight digits. If we had only the minimum number, then the maximum would be assumed to be the same as the minimum, so it matched numbers with exactly four digits. Those are probably the two most commonly used cases. There is also a third one, though. Which is where we provide the minimum value and then a comma, but we don't state a maximum value. In that case, the maximum value is assumed to be infinite. We don't really have a good character we can type in there for infinity. So the way we do it, is we provide a minimum with a comma and don't specify the maximum. That matches numbers that have four or more digits. Between regular repetition and quantified repetition, we have a wide range of ability to specify how many times something will be repeated in a pattern. There is some overlap between them. For example, if I use quantified repetition and say the minimum is zero and the maximum is infinite, it's the same thing as using the asterisk repetition operator, where something can occur zero, one, or more times. If I use one as the minimum and leave the maximum as infinite, it's the same as using the plus repetition operator. One of the most common ways that quantified repetition is used is on standardized data where numbers match a specific pattern. A great example of that is phone numbers. US phone numbers have three digits, then a dash, then three digits, then a dash, and then four digits. So we can write a regular expression that matches that using backslash d and quantified repetition. Another example, if we imagine that we were searching in a financial document, and we wanted to only find references to bonds, which are A bonds or double A bonds, spelled as AA, but not triple A bonds, AAA bonds, we could quantify the number of A's that we're looking for. Can either be one or two, but nothing else. A great way to experiment and to see this is to give ourselves some text where we write number one, period, and then a space, and then the letter a. Let's do two, space, ab, three dot space, abc, four dot space, abcd, we'll just keep going til we have a few of these. All right, I think getting to F is enough. And then, let's try writing some text up here. We know that it's going to start with any digit at the beginning, and then a literal period, and then a space, and then after that, we're going to have a word character. It could be any number of word characters. Let's just do a plus sign first. And let's do backslash s to indicate the line return that should be at the end. So you can see right now, I'm not quantifying the repetition and it matches everything. If I instead change this to not be a plus sign, but to be curly braces, and I put a two in here, you see it matches the two letter word. If I put a three in here, it matches the three letter word. If I put a five in here, it matches the five letter word. Now let's try doing three, comma, five, and you'll see that it matches a three, four, or five letter word. Any of those will match. If I leave the five off and just have three, comma, now it's three minimum and the maximum is infinite. So it matches all of the other possibilities, it just doesn't match the ones that are one and two characters long. Or if I take away the comma, now it's exactly three characters again. Play around with it a bit. It's a good way for you to experiment. Now, obviously, if I do three, comma, two, it doesn't work. It returns an error because maximum should be greater than the minimum. And I have to provide something. If I don't provide anything, it doesn't match anything at all. It can be zero, that's possible. I could say zero, comma, one, and it would match examples that have zero characters or one character as well. When you're done experimenting with it, on your own, just try a simple exercise. Make yourself a phone number. And it can be for whatever country you're from. And then, on your own, without going back and looking at the hints I gave you earlier, try to write a quantified repetition expression that will match that pattern.

----

### __----- BULLET POINT NOTES -----__